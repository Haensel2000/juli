import os;
import os.path;
import subprocess;
          
CPPUTILS_PATH = ARGUMENTS.get('cpputils', None)
LLVM_PATH = ARGUMENTS.get('llvm', None)
ANTLR3C_PATH = ARGUMENTS.get('antlr3c', None)

include_path = ['src']
lib_path = []

if CPPUTILS_PATH:
  include_path.append(os.path.join(CPPUTILS_PATH, 'src'))
if ANTLR3C_PATH:
  include_path.append(os.path.join(ANTLR3C_PATH, 'include'))
  
if CPPUTILS_PATH:
  lib_path.append(os.path.join(CPPUTILS_PATH, 'build'))
if LLVM_PATH:
  lib_path.append(subprocess.check_output(os.path.join(LLVM_PATH, 'bin', 'llvm-config') + " --libdir", shell=True))
if ANTLR3C_PATH:
  lib_path.append(os.path.join(ANTLR3C_PATH, 'lib'))

libs=[
  'pthread', 
  'm', 
  'antlr3c', 
  'cpputils', 
  'dl']

#ccflags = '-D_DEBUG -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -g -fvisibility-inlines-hidden -fno-exceptions -fno-common -Woverloaded-virtual -Wcast-qual'

if LLVM_PATH:
    ccflags_raw = subprocess.check_output(os.path.join(LLVM_PATH, 'bin', 'llvm-config') + " --cxxflags", shell=True).split()
    ccflags = ' '.join([f for f in ccflags_raw if not f.startswith('-I')])
    include_path = include_path + [f[2:] for f in ccflags_raw if f.startswith('-I')]
    libs = libs + [f[2:] for f in subprocess.check_output(os.path.join(LLVM_PATH, 'bin', 'llvm-config') + " --libs all", shell=True).split()]
else:
    ccflags = ''

source_files = ['#' + os.path.join(r,f).replace('src', 'build') for r,d,fs in os.walk('src') for f in fs if f.endswith('.cpp')]

print 'SOURCE FILES = ' + str(source_files)

env = Environment(CC = 'g++',
                  CPPPATH = include_path, 
                  LIBPATH=lib_path, 
                  LIBS=libs, 
                  CCFLAGS=ccflags,
                  source_files=source_files)   
VariantDir('build', 'src', duplicate=0)

app = os.path.join('src', 'parser', 'antlr');

env.Command([os.path.join(app, f) for f in ['JLLexer.h', 'JLLexer.c', 'JLParser.h', 'JLParser.c']], 
os.path.join(app, 'JL.g'), "java -cp libs/antlr-3.4.jar org.antlr.Tool $SOURCE")
objs = env.Object(target='#build/JLParser', source=os.path.join(app, 'JLParser.c')) + env.Object(target='#build/JLLexer', source=os.path.join(app, 'JLLexer.c'))

env.Program(target='build/jlc', source=source_files + objs)

Clean('.', 'build')
