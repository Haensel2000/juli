import os;
import os.path;
import subprocess;
          
CPPUTILS_PATH = ARGUMENTS.get('cpputils', None)
LLVM_PATH = ARGUMENTS.get('llvm', None)
ANTLR3C_PATH = ARGUMENTS.get('antlr3c', None)

include_path = ['src']
lib_path = []

if CPPUTILS_PATH:
  include_path.append(os.path.join(CPPUTILS_PATH, 'src'))
if LLVM_PATH:
  include_path.append(os.path.join(LLVM_PATH, 'include'))
if ANTLR3C_PATH:
  include_path.append(os.path.join(ANTLR3C_PATH, 'include'))
  
if CPPUTILS_PATH:
  lib_path.append(os.path.join(CPPUTILS_PATH, 'build'))
if LLVM_PATH:
  lib_path.append(os.path.join(LLVM_PATH, 'lib'))
if ANTLR3C_PATH:
  lib_path.append(os.path.join(ANTLR3C_PATH, 'lib'))

libs=[
  'pthread', 
  'm', 
  'antlr3c', 
  'cpputils', 
  'LLVMAsmParser',
  'LLVMInstrumentation',
'LLVMLinker',
'LLVMArchive',
'LLVMBitReader',
'LLVMDebugInfo',
'LLVMipo',
'LLVMVectorize',
'LLVMBitWriter',
'LLVMTableGen',
'LLVMHexagonCodeGen',
'LLVMHexagonDesc',
'LLVMHexagonInfo',
'LLVMHexagonAsmPrinter',
'LLVMNVPTXCodeGen',
'LLVMNVPTXDesc',
'LLVMNVPTXInfo',
'LLVMNVPTXAsmPrinter',
'LLVMMBlazeDisassembler',
'LLVMMBlazeAsmParser',
'LLVMMBlazeCodeGen',
'LLVMMBlazeDesc',
'LLVMMBlazeInfo',
'LLVMMBlazeAsmPrinter',
'LLVMCppBackendCodeGen',
'LLVMCppBackendInfo',
'LLVMMSP430CodeGen',
'LLVMMSP430Desc',
'LLVMMSP430AsmPrinter',
'LLVMMSP430Info',
'LLVMXCoreCodeGen',
'LLVMXCoreDesc',
'LLVMXCoreInfo',
'LLVMMipsCodeGen',
'LLVMMipsAsmParser',
'LLVMMipsDisassembler',
'LLVMMipsDesc',
'LLVMMipsAsmPrinter',
'LLVMMipsInfo',
'LLVMARMDisassembler',
'LLVMARMCodeGen',
'LLVMARMAsmParser',
'LLVMARMDesc',
'LLVMARMInfo',
'LLVMARMAsmPrinter',
'LLVMPowerPCCodeGen',
'LLVMPowerPCDesc',
'LLVMPowerPCAsmPrinter',
'LLVMPowerPCInfo',
'LLVMSparcCodeGen',
'LLVMSparcDesc',
'LLVMSparcInfo',
'LLVMX86AsmParser',
'LLVMX86CodeGen',
'LLVMSelectionDAG',
'LLVMAsmPrinter',
'LLVMX86Disassembler',
'LLVMX86Desc',
'LLVMX86Info',
'LLVMX86AsmPrinter',
'LLVMX86Utils',
'LLVMMCDisassembler',
'LLVMMCParser',
'LLVMInterpreter',
'LLVMMCJIT',
'LLVMJIT',
'LLVMCodeGen',
'LLVMScalarOpts',
'LLVMInstCombine',
'LLVMTransformUtils',
'LLVMipa',
'LLVMAnalysis',
'LLVMRuntimeDyld',
'LLVMExecutionEngine',
'LLVMTarget',
'LLVMMC',
'LLVMObject',
'LLVMCore',
'LLVMSupport',
  'dl']

#ccflags = '-D_DEBUG -D_GNU_SOURCE -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -g -fvisibility-inlines-hidden -fno-exceptions -fno-common -Woverloaded-virtual -Wcast-qual'

if LLVM_PATH:
    ccflags_raw = subprocess.check_output(os.path.join(LLVM_PATH, 'bin', 'llvm-config') + " --cxxflags", shell=True).split()
    ccflags = ' '.join([f for f in ccflags_raw if not f.startswith('-I')])
    print 'CCFLAGS = ' + ccflags
else:
    ccflags = ''

source_files = ['#' + os.path.join(r,f).replace('src', 'build') for r,d,fs in os.walk('src') for f in fs if f.endswith('.cpp')]

print 'SOURCE FILES = ' + str(source_files)

env = Environment(CC = 'g++',
                  CPPPATH = include_path, 
                  LIBPATH=lib_path, 
                  LIBS=libs, 
                  CCFLAGS=ccflags,
                  source_files=source_files)   
VariantDir('build', 'src', duplicate=0)

app = os.path.join('src', 'parser', 'antlr');

env.Command([os.path.join(app, f) for f in ['JLLexer.h', 'JLLexer.c', 'JLParser.h', 'JLParser.c']], 
os.path.join(app, 'JL.g'), "java -cp libs/antlr-3.4.jar org.antlr.Tool $SOURCE")
objs = env.Object(target='#build/JLParser', source=os.path.join(app, 'JLParser.c')) + env.Object(target='#build/JLLexer', source=os.path.join(app, 'JLLexer.c'))

env.Program(target='build/jlc', source=source_files + objs)

Clean('.', 'build')
